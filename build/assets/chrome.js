const E={message:"Microtab"},L={message:"Chromium extension designed to customize the empty new tab page."},j={message:"Close the current tab"},x={message:"Settings"},A={message:"Close"},H={message:"Light Background Color"},O={message:"Dark Background Color"},T={message:"Choose Backround Image"},z={message:"The maximum allowed image size is 8 MB."},R={message:"Remove Background Image"},V={message:"Style"},W={message:"Cover"},_={message:"Fit the background image to the size of the window."},F={message:"Repeat"},G={message:"Repeat the background image across the entire window."},K={message:"Center"},N={message:"Show the background image in the center of the window."},J={message:"Size"},$={message:"Adjust the size of the background image."},Q={message:"The background image size cannot be adjusted when using the cover style."},U={message:"Opacity"},X={message:"Adjust the opacity of the background image."},Y={message:"Hue"},Z={message:"Adjust the hue rotation of the image."},q={message:"Grayscale"},ee={message:"Adjust the grayscale level of the background image."},te={message:"Blur"},se={message:"Adjust the blur level of the background image."},ne={message:"Tired of accidentally closing tabs or the browser window when closing the last tab? Configure the alternative Close Tab shortcut to avoid this frustration."},oe={message:"Prevent closing pinned tabs"},re={message:"When this option is enabled, pinned tabs will not be closed when using the keyboard shortcut to close tabs."},ae={message:"Prevent closing tabs within groups"},ie={message:"When this option is enabled, grouped tabs will not be closed when using the keyboard shortcut to close tabs."},ce={message:"Configure Keyboard Shortcuts"},ue={message:"Reset"},ge={message:"Are you sure you want to restore the default settings?"},le={name:E,description:L,closeCommand:j,settings:x,close:A,colorLight:H,colorDark:O,image:T,imageError:z,imageRemove:R,imageStyle:V,imageStyleCover:W,imageStyleCoverHelp:_,imageStyleRepeat:F,imageStyleRepeatHelp:G,imageStyleCenter:K,imageStyleCenterHelp:N,imageSize:J,imageSizeHelp:$,imageSizeDisabledHelp:Q,imageOpacity:U,imageOpacityHelp:X,imageHue:Y,imageHueHelp:Z,imageGrayscale:q,imageGrayscaleHelp:ee,imageBlur:te,imageBlurHelp:se,closeDescription:ne,closePinned:oe,closePinnedHelp:re,closeGrouped:ae,closeGroupedHelp:ie,closeShortcut:ce,reset:ue,resetConfirm:ge},y=(e,t)=>t.some(s=>e instanceof s);let D,S;function de(){return D||(D=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function me(){return S||(S=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const b=new WeakMap,h=new WeakMap,l=new WeakMap;function he(e){const t=new Promise((s,n)=>{const a=()=>{e.removeEventListener("success",i),e.removeEventListener("error",o)},i=()=>{s(u(e.result)),a()},o=()=>{n(e.error),a()};e.addEventListener("success",i),e.addEventListener("error",o)});return l.set(t,e),t}function fe(e){if(b.has(e))return;const t=new Promise((s,n)=>{const a=()=>{e.removeEventListener("complete",i),e.removeEventListener("error",o),e.removeEventListener("abort",o)},i=()=>{s(),a()},o=()=>{n(e.error||new DOMException("AbortError","AbortError")),a()};e.addEventListener("complete",i),e.addEventListener("error",o),e.addEventListener("abort",o)});b.set(e,t)}let w={get(e,t,s){if(e instanceof IDBTransaction){if(t==="done")return b.get(e);if(t==="store")return s.objectStoreNames[1]?void 0:s.objectStore(s.objectStoreNames[0])}return u(e[t])},set(e,t,s){return e[t]=s,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function v(e){w=e(w)}function ye(e){return me().includes(e)?function(...t){return e.apply(p(this),t),u(this.request)}:function(...t){return u(e.apply(p(this),t))}}function be(e){return typeof e=="function"?ye(e):(e instanceof IDBTransaction&&fe(e),y(e,de())?new Proxy(e,w):e)}function u(e){if(e instanceof IDBRequest)return he(e);if(h.has(e))return h.get(e);const t=be(e);return t!==e&&(h.set(e,t),l.set(t,e)),t}const p=e=>l.get(e);function we(e,t,{blocked:s,upgrade:n,blocking:a,terminated:i}={}){const o=indexedDB.open(e,t),g=u(o);return n&&o.addEventListener("upgradeneeded",r=>{n(u(o.result),r.oldVersion,r.newVersion,u(o.transaction),r)}),s&&o.addEventListener("blocked",r=>s(r.oldVersion,r.newVersion,r)),g.then(r=>{i&&r.addEventListener("close",()=>i()),a&&r.addEventListener("versionchange",c=>a(c.oldVersion,c.newVersion,c))}).catch(()=>{}),g}const pe=["get","getKey","getAll","getAllKeys","count"],Ie=["put","add","delete","clear"],f=new Map;function B(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(f.get(t))return f.get(t);const s=t.replace(/FromIndex$/,""),n=t!==s,a=Ie.includes(s);if(!(s in(n?IDBIndex:IDBObjectStore).prototype)||!(a||pe.includes(s)))return;const i=async function(o,...g){const r=this.transaction(o,a?"readwrite":"readonly");let c=r.store;return n&&(c=c.index(g.shift())),(await Promise.all([c[s](...g),a&&r.done]))[0]};return f.set(t,i),i}v(e=>({...e,get:(t,s,n)=>B(t,s)||e.get(t,s,n),has:(t,s)=>!!B(t,s)||e.has(t,s)}));const De=["continue","continuePrimaryKey","advance"],C={},I=new WeakMap,M=new WeakMap,Se={get(e,t){if(!De.includes(t))return e[t];let s=C[t];return s||(s=C[t]=function(...n){I.set(this,M.get(this)[t](...n))}),s}};async function*Be(...e){let t=this;if(t instanceof IDBCursor||(t=await t.openCursor(...e)),!t)return;t=t;const s=new Proxy(t,Se);for(M.set(s,t),l.set(s,p(t));t;)yield s,t=await(I.get(s)||t.continue()),I.delete(s)}function k(e,t){return t===Symbol.asyncIterator&&y(e,[IDBIndex,IDBObjectStore,IDBCursor])||t==="iterate"&&y(e,[IDBIndex,IDBObjectStore])}v(e=>({...e,get(t,s,n){return k(t,s)?Be:e.get(t,s,n)},has(t,s){return k(t,s)||e.has(t,s)}}));const P=we("microtab",1,{upgrade(e){e.createObjectStore("key_value")}});function d(){}d.get=async e=>(await P).get("key_value",e);d.set=async(e,t)=>(await P).put("key_value",t,e);const Ce={color:{light:null,dark:null},image:{style:"cover",size:100,opacity:100,hue:0,grayscale:0,blur:0},close:{pinned:!0,grouped:!0}},ke=le;function m(){}m.getMessage=(e,t)=>{try{return chrome.i18n.getMessage(e,t)}catch{return ke[e].message||""}};m.getSettings=async()=>{const e=structuredClone(Ce);let t=await d.get("settings");if(!t||!Object.keys(t).length)try{t=(await chrome.storage.local.get(["page"])).page||e}catch{t=e}return t};m.saveSettings=async(e,t=!1)=>{await d.set("settings",e),window.localStorage.setItem("page-color",JSON.stringify(e.color));try{await chrome.storage.local.set({page:e})}catch{}t&&window.location.reload()};m.openShortcuts=()=>{try{chrome.tabs.create({url:"chrome://extensions/shortcuts"})}catch{}};export{m as c,Ce as d};
